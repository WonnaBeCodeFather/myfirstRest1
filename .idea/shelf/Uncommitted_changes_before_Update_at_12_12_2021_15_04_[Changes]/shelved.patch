Index: mysite/dixi/models.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import datetime\r\nfrom django.db import models\r\nfrom django.db.models.signals import post_save\r\nfrom django.dispatch import receiver\r\nfrom django.urls import reverse\r\nfrom django.contrib.auth.models import User\r\nfrom django.core.mail import send_mail\r\nfrom pytils.translit import slugify\r\n\r\n\r\nclass Product(models.Model):\r\n    class Gender(models.IntegerChoices):\r\n        Men = 1, 'Мужской'\r\n        Women = 2, 'Женский'\r\n\r\n    class Season(models.IntegerChoices):\r\n        demi = 1, 'Демисезон'\r\n        summer = 2, 'Лето'\r\n        winter = 3, 'Зима'\r\n\r\n    name = models.CharField(max_length=100, verbose_name='Наименование модели')\r\n    material = models.ForeignKey('Material', on_delete=models.CASCADE, verbose_name='Матераил')\r\n    category = models.ForeignKey('Category', on_delete=models.CASCADE, verbose_name='Категория')\r\n    slug = models.SlugField(unique=True, blank=True, null=True, help_text='<font color=\"red\">'\r\n                                                                          'Поле заполняется автоматически!</font>')\r\n    amount = models.IntegerField(verbose_name='Количество товара', default=0)\r\n    season = models.IntegerField(verbose_name='Сезон', choices=Season.choices)\r\n    factory = models.CharField(max_length=50, verbose_name='Фабрика')\r\n    size = models.IntegerField(verbose_name='Размер обуви', default=36)\r\n    gender = models.IntegerField(verbose_name='Пол', choices=Gender.choices)\r\n\r\n    def __str__(self):\r\n        return self.name\r\n\r\n    def get_absolute_url(self):\r\n        return reverse('post', kwargs={'post_id': self.pk})\r\n\r\n    class Meta:\r\n        verbose_name = 'Модель'\r\n        verbose_name_plural = 'Модели'\r\n\r\n    def save(self, *args, **kwargs):\r\n        get_name = str(self.name) + str(self.size)\r\n        self.slug = slugify(get_name)\r\n        super(Product, self).save(*args, **kwargs)\r\n\r\n\r\nclass Category(models.Model):\r\n    name = models.CharField(max_length=50, verbose_name='Имя категории')\r\n    slug = models.SlugField(unique=True)\r\n\r\n    def __str__(self):\r\n        return self.name\r\n\r\n    class Meta:\r\n        verbose_name = 'Категория товара'\r\n        verbose_name_plural = 'Категории товара'\r\n\r\n\r\nclass Price(models.Model):\r\n    name_model = models.ForeignKey(Product, on_delete=models.CASCADE, verbose_name='Модель',\r\n                                   related_name='price')\r\n    price = models.DecimalField(max_digits=9, decimal_places=2, verbose_name='Цена товара', default=00.00,\r\n                                )\r\n    discount_bool = models.BooleanField(default=False, verbose_name='Наличие скидки')\r\n    discount = models.PositiveIntegerField(default=0, blank=True, verbose_name='Скидка в %')\r\n    new_price = models.DecimalField(max_digits=9, decimal_places=2, verbose_name='Цена товара с учетом скидки',\r\n                                    default=00.00, blank=True, help_text='<font color=\"red\">'\r\n                                                                         'Цена пересчитывается автоматически,'\r\n                                                                         'поле заполнять не нужно!</font>')\r\n\r\n    def __str__(self):\r\n        return f'Цена для {self.name_model}'\r\n\r\n    \"\"\"Если поле discount_bool = True, то автоматически заполнятеся поле new_price с учётом указанной скидки в \r\n    процентах, а иначе поля new_price и discount устанавливаются в 0. Поле price остаётся неизменным в любом случае.\r\n    \"\"\"\r\n\r\n    def save(self, *args, **kwargs):\r\n        if self.discount_bool:\r\n            new_price = float(self.price) - (float(self.price) * (float(self.discount) / 100))\r\n            self.new_price = new_price\r\n        else:\r\n            self.new_price = 0.00\r\n            self.discount = 0\r\n        super(Price, self).save(*args, **kwargs)\r\n\r\n    class Meta:\r\n        verbose_name = 'Цена'\r\n        verbose_name_plural = 'Цены'\r\n\r\n\r\n@receiver(post_save, sender=Price)\r\ndef testsignal(sender, instance, created, **kwargs):\r\n    print(instance.name_model)\r\n    print('Hi')\r\n\r\n\r\nclass Material(models.Model):\r\n    name_model = models.CharField(max_length=50, verbose_name='Материал')\r\n\r\n    def __str__(self):\r\n        return self.name_model\r\n\r\n    class Meta:\r\n        verbose_name = 'Материал'\r\n        verbose_name_plural = 'Материал'\r\n\r\n\r\nclass Gallery(models.Model):\r\n    name = models.ForeignKey(Product, on_delete=models.CASCADE, verbose_name='Наименование модели')\r\n    image = models.ImageField(verbose_name='Фото', null=True)\r\n\r\n    def __str__(self):\r\n        return f'Фотография {self.name}'\r\n\r\n    class Meta:\r\n        verbose_name = 'Галерея'\r\n        verbose_name_plural = 'Галерея'\r\n\r\n\r\nclass Reviews(models.Model):\r\n    owner = models.ForeignKey(User, on_delete=models.CASCADE, related_name='owner')\r\n    name = models.CharField(max_length=100, verbose_name='Имя')\r\n    text = models.TextField(max_length=5000, verbose_name='Отзыв')\r\n    name_product = models.ForeignKey(Product, verbose_name='Название продукта', on_delete=models.CASCADE,\r\n                                     related_name='reviews')\r\n    parent = models.ForeignKey('self', verbose_name='Родитель', on_delete=models.CASCADE, blank=True, null=True,\r\n                               related_name='children')\r\n\r\n    class Meta:\r\n        verbose_name = 'Отзыв'\r\n        verbose_name_plural = 'Отзывы'\r\n\r\n    def __str__(self):\r\n        return f'Отзыв на модель {self.name_product}'\r\n\r\n\r\nclass Cart(models.Model):\r\n    owner = models.OneToOneField(User, on_delete=models.CASCADE, verbose_name='Владелец корзины', null=True, blank=True)\r\n    data_create = models.DateTimeField(auto_now=True)\r\n\r\n    def __str__(self):\r\n        return f'Корзина для пользователя {self.owner}'\r\n\r\n    class Meta:\r\n        verbose_name = 'Корзина'\r\n        verbose_name_plural = 'Корзина'\r\n\r\n    \"\"\"При создании новой корзины проверяется есть ли корзины созданные 14 дней назад и если они есть, то эти корзины\r\n     удаляются. Это связанно с тем, что корзину для анонимного пользователя я привязал к сессии срок котрой ровно 14 \r\n     дней\"\"\"\r\n\r\n    def save(self, *args, **kwargs):\r\n        now = datetime.datetime.now() - datetime.timedelta(days=1)\r\n        super().save(*args, **kwargs)\r\n        Cart.objects.filter(data_create__lte=now).delete()\r\n\r\n\r\nclass CartProduct(models.Model):\r\n    owner = models.ForeignKey(Cart, on_delete=models.CASCADE, verbose_name='Корзина для пользователя', null=True,\r\n                              blank=True, related_name='product')\r\n    products = models.ForeignKey(Product, on_delete=models.CASCADE, verbose_name='Продукты в корзине')\r\n    amount = models.PositiveIntegerField(default=1, verbose_name='Количество товара')\r\n    price = models.DecimalField(decimal_places=2, max_digits=7, blank=True, verbose_name='Общая Цена')\r\n\r\n    class Meta:\r\n        verbose_name = 'Товар в корзине'\r\n        verbose_name_plural = 'Товары в корзине'\r\n\r\n    def __str__(self):\r\n        return f'Товары пользователя {self.owner}'\r\n\r\n    \"\"\"Если на продукт в корзине есть скидка то в общую стоимость продукта входит цена с учётом скидки. Так же если\r\n    в корзине содержатся модели обуви с одинаковым названием но с разными размерами то цена подтягивается по названию\r\n    обуви. Если пользователь добавляет товар в корзину повторно, то он не добавляются\"\"\"\r\n\r\n    def save(self, *args, **kwargs):\r\n        get_name = self.products.name\r\n        get_first_id = Product.objects.filter(name=get_name)[0].pk\r\n        if Price.objects.get(name_model=get_first_id).discount_bool:\r\n            self.price = Price.objects.get(name_model=self.products).new_price\r\n            self.price = self.price * self.amount\r\n        else:\r\n            self.price = Price.objects.get(name_model=get_first_id).price\r\n            self.price = self.price * self.amount\r\n        if not CartProduct.objects.filter(owner=self.owner):\r\n            super(CartProduct, self).save(*args, **kwargs)\r\n        else:\r\n            for i in CartProduct.objects.filter(owner=self.owner):\r\n                if i.products != self.products:\r\n                    super(CartProduct, self).save(*args, **kwargs)\r\n\r\n\r\nclass Order(models.Model):\r\n    owner = models.OneToOneField(Cart, on_delete=models.SET_NULL, verbose_name='Заказ Пользователя', null=True)\r\n    first_name = models.CharField(max_length=100, verbose_name='Имя')\r\n    last_name = models.CharField(max_length=100, verbose_name='Фамилия')\r\n    phone_number = models.CharField(max_length=13, verbose_name='Номер телефона')\r\n    delivery_address = models.CharField(max_length=500, verbose_name='Адресс доставки')\r\n    description = models.TextField(verbose_name='Комментарий', blank=True, null=True)\r\n    final_price = models.TextField(verbose_name='Итоговая Цена', blank=True)\r\n    order_date_create = models.DateTimeField(auto_now=True)\r\n\r\n    class Meta:\r\n        verbose_name = 'Оформление заказа'\r\n        verbose_name_plural = verbose_name\r\n\r\n    \"\"\"Пересчет общей суммы заказа всех товаров в корзине. Отправка письма продавцу на почту со всем содержимым заказа.\r\n    После оформления заказа, количество проданного товара вычитается из общего количества товара в модели Product\r\n    \"\"\"\r\n\r\n    def save(self, *args, **kwargs):\r\n        lists = []\r\n        for i in CartProduct.objects.filter(owner=self.owner):\r\n            lists.append(float(i.price))\r\n        self.final_price = sum(lists)\r\n        send_mail(subject='Test', message=f'Имя - {self.first_name},\\n '\r\n                                          f'Фамилия - {self.last_name},\\n'\r\n                                          f'Номер телефона - {self.phone_number},\\n'\r\n                                          f'Адресс Доставки - {self.delivery_address},\\n'\r\n                                          f'Комментарии - {self.description},\\n'\r\n                                          f'Сумма заказа - {self.final_price},\\n'\r\n                                          f'Продукт и размер {({str(i.products): str(i.products.size) for i in CartProduct.objects.filter(owner=self.owner.pk)})},',\r\n                  from_email='djangodixi@gmail.com',\r\n                  recipient_list=['opiumdlyanaroda3319@gmail.com'])\r\n        for i in CartProduct.objects.filter(owner=self.owner):\r\n            get_cartproduct = CartProduct.objects.get(id=i.pk).products.pk\r\n            get_cartproduct_amount = CartProduct.objects.get(id=i.pk).amount\r\n            get_product = Product.objects.get(id=get_cartproduct)\r\n            get_product.amount = get_product.amount - get_cartproduct_amount\r\n            get_product.save()\r\n        super().save(*args, **kwargs)\r\n        CartProduct.objects.filter(owner=self.owner.pk).delete()\r\n\r\n    def __str__(self):\r\n        return f'Заказ для {self.last_name} {self.first_name}'\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mysite/dixi/models.py b/mysite/dixi/models.py
--- a/mysite/dixi/models.py	(revision 631c6e96cea7bb91708dbcba78d407245c145f41)
+++ b/mysite/dixi/models.py	(date 1639314148413)
@@ -152,7 +152,7 @@
      дней"""
 
     def save(self, *args, **kwargs):
-        now = datetime.datetime.now() - datetime.timedelta(days=1)
+        now = datetime.datetime.now() - datetime.timedelta(days=14)
         super().save(*args, **kwargs)
         Cart.objects.filter(data_create__lte=now).delete()
 
